<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Karte ‚Äî NAVIS Marine Dashboard</title>
    <!-- Lokale Leaflet Dateien -->
    <link rel="stylesheet" href="leaflet/leaflet.css">
    <style>
        /* üü¶ GRUNDLAYOUT */
        body { margin:0; background:#1c1f26; color:#fff; height:100vh; display:flex; flex-direction:column; align-items:center; font-family:"Segoe UI",Roboto,Arial,sans-serif; transition:background 0.6s,color 0.6s,filter 0.6s; }

        /* üü® NAVBAR */
        #navbar { display:flex; justify-content:center; gap:8px; background:#002b3a; padding:4px 0; border-bottom:1px solid #005566; width:100%; transition:background 0.6s,border 0.6s; }
        .navbtn { background:#003d52; color:#00ffff; border:1px solid #007a99; border-radius:5px; padding:3px 10px; text-decoration:none; font-size:0.9em; font-weight:bold; transition:background 0.6s,color 0.6s,border 0.6s; }
        .navbtn:hover { background:#00b8d4; color:#001a26; }

        /* üü© PANEL UND KARTE */
        .panel { width:98vw; background:#2a2f38; border-radius:12px; position:relative; margin-top:6px; box-shadow:0 8px 28px rgba(0,0,0,0.6); display:flex; flex-direction:column; align-items:stretch; transition:background 0.6s,box-shadow 0.6s; }
        #map { width:100%; height:93vh; position:relative; z-index:1; transition:filter 0.6s; }

        /* üü™ BUTTONS */
        button { background:rgba(0,0,0,0.4); color:#fff; padding:6px 10px; border-radius:10px; border:none; cursor:pointer; font-size:13px; box-shadow:0 4px 12px rgba(0,0,0,0.6); transition:background 0.3s,color 0.3s,box-shadow 0.3s; }
        button:hover { background:rgba(0,0,0,0.6); }
        #centerToggle { position:absolute; right:14px; top:14px; z-index:1000; }
        #saveTrack { position:absolute; right:14px; top:48px; z-index:1000; }
        #anchorWatch { position:absolute; right:14px; top:82px; z-index:1000; }
        #modeRoute { position:absolute; right:14px; top:116px; z-index:1000; }
        #nightToggle { position:absolute; right:14px; top:150px; z-index:1000; }

        /* üü´ INFOBOXEN, LEGENDE UND ALARME */
        #waypointInfo { position:absolute; top:14px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.4); padding:6px 10px; border-radius:10px; font-size:13px; z-index:1000; transition:background 0.6s,color 0.6s; }
        #alarmOverlay { position:absolute; inset:0; background:rgba(0,0,0,0.85); color:red; font-size:6vw; font-weight:bold; display:none; align-items:center; justify-content:center; text-align:center; z-index:2000; animation:blink 1s infinite; }
        #legend { position:absolute; bottom:12px; left:12px; background:rgba(0,0,0,0.5); padding:6px 10px; border-radius:10px; font-size:12px; line-height:1.4; z-index:1000; transition:background 0.6s,color 0.6s; }
        @keyframes blink { 0%,50% { opacity:1; } 51%,100% { opacity:0.5; } }

        /* üåô NACHTMODUS */
        body.night-mode { background:#000; color:#ffb; }
        body.night-mode #map { filter:brightness(0.4) contrast(1.2) sepia(0.9) hue-rotate(-25deg) saturate(1.4); }
        body.night-mode .panel { background:#1a0000; box-shadow:0 0 20px rgba(255,100,50,0.1); }
        body.night-mode #navbar { background:#1a0000; border-bottom:1px solid #330000; }
        body.night-mode .navbtn { background:#330000; color:#ff9966; border:1px solid #663333; }
        body.night-mode .navbtn:hover { background:#660000; color:#fff; }
        body.night-mode button { background:rgba(255,100,50,0.08); color:#ffb199; box-shadow:0 0 10px rgba(255,80,40,0.2); }
        body.night-mode button:hover { background:rgba(255,100,50,0.2); }

        /* üü™ WAYPOINT LISTE & TABELLEN */
        #waypointListContainer { position:absolute; bottom:-100%; left:0; width:95%; max-height:40vh; background:rgba(0,0,0,0.85); color:white; overflow-y:auto; transition:bottom 0.4s ease; z-index:9999; backdrop-filter:blur(6px); padding:10px; }
        #waypointListContainer.visible { bottom:0; }
        #waypointTable { width:100%; border-collapse:collapse; }
        #waypointTable th, #waypointTable td { padding:4px 8px; border-bottom:1px solid #003040; text-align:center; white-space:nowrap; }
        #waypointTable th { background:rgba(0,80,100,0.6); position:sticky; top:0; }
        #waypointTable button { padding:3px 6px; background:#006680; border-radius:5px; color:#fff; border:none; cursor:pointer; }
        #waypointTable button:hover { background:#00b0c0; }
    </style>
</head>
<body>
<div id="navbar">
    <a href="index.html" class="navbtn">NAVIS</a>
    <a href="kompass.html" class="navbtn">Kompass</a>
    <a href="horizont.html" class="navbtn">Horizont</a>
    <a href="autopilot.html" class="navbtn">Autopilot</a>
</div>
<div class="panel">
    <div id="map"></div>
    <div id="waypointListContainer">
        <table id="waypointTable">
            <thead>
                <tr>
                    <th>Nr.</th>
                    <th>Lat</th>
                    <th>Lon</th>
                    <th>Kurs vom Schiff</th>
                    <th>Distanz vom Schiff (sm)</th>
                    <th>Kurs vom vorh. WP</th>
                    <th>Distanz vom WP (sm)</th>
                    <th>Autopilot</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
    <button id="centerToggle">üß≠ Zentrieren</button>
    <button id="saveTrack">üíæ Track speichern</button>
    <button id="anchorWatch">‚öì Ankerwache</button>
    <button id="modeRoute">üìç Peil / Route</button>
    <button id="nightToggle">üåô Nachtmodus</button>
    <div id="waypointInfo"></div>
    <div id="alarmOverlay">üö® ANKERWACHE ALARM üö®<br>Boot hat den Radius verlassen!<br><br>(Klick zum Best√§tigen)</div>
    <div id="legend">üî¥ Kompasskurs: --¬∞<br>üü° GPS-Kurs: --¬∞<br>üü¢ Wind: --¬∞ / -- kn</div>
</div>
<script src="leaflet/leaflet.js"></script>
<script>
/* ------------------------------
   Konfiguration / global state
   ------------------------------ */
const DATA_URL = '/data.json';
const POLL_INTERVAL_MS = 1000;
const GPS_UNGENAUIGKEIT = 15;

let demoMode = false;
let followMode = false;
let anchorActive = false;
let anchorPos = null;
let anchorRadius = 50;
let routeMode = false; // false = Peilmodus, true = Routenmodus

const state = {
  gps_lat: 54.6,
  gps_lon: 10.3,
  gps_speed: 0,
  gps_kurs: 90,
  kompass: 90,
  winddir_berechnet: 120,
  windspeed_berechnet: 0
};
const target = JSON.parse(JSON.stringify(state));

let ogpsCounter = 0;
const trackPoints = [];
const ogpsMarkers = [];

/* ------------------------------
   Wegpunkte / Marker / Linien (ohne Tabelle)
   ------------------------------ */
let routePoints = [];       // LatLng-Objekte
let routeMarkers = [];      // L.marker-Objekte
let routeLine = null;       // L.polyline f√ºr die blaue Linie

/* ------------------------------
   Karte & Layer (offline)
   ------------------------------ */
const map = L.map('map', { zoomControl: true, attributionControl: false })

  .setView([state.gps_lat, state.gps_lon], 10);

// Lokale Tile-Layer
const layerOSM = L.tileLayer('tiles/osm/{z}/{x}/{y}.png', {
  maxZoom: 18,
  attribution: '¬© OpenStreetMap contributors'
});

// Standard Layer hinzuf√ºgen
layerOSM.addTo(map);

// Layer Control (Nur OSM)
L.control.layers(
  {
    "OpenStreetMap": layerOSM,
  },
  {},
  {
    collapsed: false,
    position: 'bottomright'
  }
).addTo(map);

/* ------------------------------
   Grid, CoordBox, Geodesy etc.
   (unver√§ndert aus deinem Code)
   ------------------------------ */
function addLatLonGrid(map, stepSm = 1) {
  const minZoomToShow = 8; // Raster erscheint schon ab Zoom 8
  const bounds = map.getBounds();

  // Raster entfernen, wenn Zoom zu klein (Kartenausschnitt gro√ü)
  if (map.getZoom() < minZoomToShow) {
    if (window.gridLines) {
      window.gridLines.forEach(l => map.removeLayer(l));
      window.gridLines = [];
    }
    return;
  }

  const step = stepSm / 60; // 1 sm ‚âà 1/60¬∞ Latitude
  const latMin = Math.floor(bounds.getSouth() / step) * step;
  const latMax = Math.ceil(bounds.getNorth() / step) * step;
  const lonMin = Math.floor(bounds.getWest() / step) * step;
  const lonMax = Math.ceil(bounds.getEast() / step) * step;

  if (window.gridLines) window.gridLines.forEach(l => map.removeLayer(l));
  window.gridLines = [];

  // Farbe / Deckkraft abh√§ngig vom Zoom: n√§her = dunkler / deutlicher
  const zoom = map.getZoom();
  const opacity = Math.min(0.8, 0.2 + 0.15 * (zoom - minZoomToShow)); // h√∂her max 0.8
  const colorValue = Math.max(50, 220 - (zoom - minZoomToShow) * 20); // dunkler bei h√∂herem Zoom
  const color = `rgb(${colorValue},${colorValue},${colorValue})`;

  for (let lon = lonMin; lon <= lonMax; lon += step) {
    const line = L.polyline([[latMin, lon], [latMax, lon]], { color: color, weight: 1, opacity: opacity, interactive: false }).addTo(map);
    window.gridLines.push(line);
  }
  for (let lat = latMin; lat <= latMax; lat += step) {
    const line = L.polyline([[lat, lonMin], [lat, lonMax]], { color: color, weight: 1, opacity: opacity, interactive: false }).addTo(map);
    window.gridLines.push(line);
  }
}

// Eventlistener f√ºr Verschiebung & Zoom
addLatLonGrid(map);
map.on("moveend zoomend", () => addLatLonGrid(map));

const coordBox = L.control({ position: "bottomleft" });
coordBox.onAdd = function(map) {
  const div = L.DomUtil.create("div", "coord-box");
  div.style.position = "fixed";
  div.style.bottom = "8px";
  div.style.left = "50%";
  div.style.transform = "translateX(-50%)";
  div.style.background = "rgba(255,255,255,0.8)";
  div.style.color = "#000000";
  div.style.fontSize = "13px";
  div.style.fontFamily = "monospace";
  div.style.padding = "4px 12px";
  div.style.borderRadius = "6px";
  div.style.textAlign = "center";
  div.style.boxShadow = "0 0 6px rgba(0,0,0,0.2)";
  div.style.pointerEvents = "none";
  div.innerHTML = "‚Äî";
  return div;
};
coordBox.addTo(map);

function toDMS(value, type) {
  const abs = Math.abs(value);
  const deg = Math.floor(abs);
  const minFull = (abs - deg) * 60;
  const min = Math.floor(minFull);
  const sec = ((minFull - min) * 60).toFixed(1);
  const hemi = type === 'lat' ? (value >= 0 ? "N" : "S") : (value >= 0 ? "E" : "W");
  return `${deg}¬∞${min}'${sec}" ${hemi}`;
}
map.on("mousemove", (e) => {
  const lat = e.latlng.lat, lon = e.latlng.lng;
  const container = coordBox.getContainer();
  if (container) container.innerHTML = `${toDMS(lat,"lat")} &nbsp;&nbsp; ${toDMS(lon,"lon")}<br>${lat.toFixed(6)}, ${lon.toFixed(6)}`;
});
map.getContainer().addEventListener("mouseleave", () => { const c = coordBox.getContainer(); if (c) c.innerHTML = "‚Äî"; });

layerOSM.on('tileerror', () => { if (!map.hasLayer(layerOSM)) map.addLayer(layerOSM); });

/* ------------------------------
   Bootsdreieck + Linien (unver√§ndert)
   ------------------------------ */
let boatTriangle = L.polygon([[state.gps_lat, state.gps_lon],[state.gps_lat, state.gps_lon],[state.gps_lat, state.gps_lon]], {
  color: '#ff0000', weight: 2, fillColor: '#ff0000', fillOpacity: 0.9, pane: 'markerPane'
}).addTo(map);

const courseLine = L.polyline([], { color:'#ff0000', weight:2, opacity:0.9 }).addTo(map);
const headingLineCompass = L.polyline([], { color:'#ff3333', weight:2, opacity:0.9 }).addTo(map);
const headingLineGPS     = L.polyline([], { color:'#d6b600', weight:2, opacity:0.9 }).addTo(map);
const headingLineWind    = L.polyline([], { color:'#00cc66', weight:2, opacity:0.9 }).addTo(map);

const legendEl = document.getElementById('legend');
const waypointInfo = document.getElementById('waypointInfo');
const alarmOverlay = document.getElementById('alarmOverlay');

function destinationPoint(lat, lon, bearing, dist) {
  const R = 6371000;
  const Œ¥ = dist / R;
  const Œ∏ = bearing * Math.PI/180;
  const œÜ1 = lat * Math.PI/180;
  const Œª1 = lon * Math.PI/180;
  const œÜ2 = Math.asin(Math.sin(œÜ1)*Math.cos(Œ¥) + Math.cos(œÜ1)*Math.sin(Œ¥)*Math.cos(Œ∏));
  const Œª2 = Œª1 + Math.atan2(Math.sin(Œ∏)*Math.sin(Œ¥)*Math.cos(œÜ1),
                             Math.cos(Œ¥)-Math.sin(œÜ1)*Math.sin(œÜ2));
  return [œÜ2*180/Math.PI, Œª2*180/Math.PI];
}
function bearingAndDistance(lat1,lon1,lat2,lon2) {
  const R = 6371000;
  const œÜ1 = lat1 * Math.PI/180;
  const œÜ2 = lat2 * Math.PI/180;
  const ŒîŒª = (lon2 - lon1) * Math.PI/180;
  const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
  const x = Math.cos(œÜ1)*Math.sin(œÜ2) - Math.sin(œÜ1)*Math.cos(œÜ2)*Math.cos(ŒîŒª);
  const brng = (Math.atan2(y,x)*180/Math.PI + 360) % 360;
  const d = R * Math.acos(Math.sin(œÜ1)*Math.sin(œÜ2) + Math.cos(œÜ1)*Math.cos(œÜ2)*Math.cos(ŒîŒª));
  return { bearing: brng, distance: d };
}

/* ------------------------------
   Alarm / Ankerwache (unver√§ndert)
   ------------------------------ */
let alarmSound = null; let alarmActive = false;
function startAlarm() { if (alarmActive) return; alarmActive = true; alarmOverlay.style.display = 'flex'; playAlarmTone(); }
function playAlarmTone(){
  if(alarmSound) return;
  try{
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    alarmSound = ctx;
    const osc = ctx.createOscillator(); osc.type='sine';
    osc.frequency.setValueAtTime(700,ctx.currentTime);
    const gain = ctx.createGain(); gain.gain.value = 0.05;
    osc.connect(gain); gain.connect(ctx.destination);
    osc.start();
    let on = true;
    const iv = setInterval(()=>{ if(!alarmActive){ try{ osc.stop(); }catch(e){} clearInterval(iv); return; } osc.frequency.setValueAtTime(on?700:1200, ctx.currentTime); on=!on; }, 450);
  }catch(e){ console.warn("AudioContext nicht verf√ºgbar:", e); }
}
function stopAlarm(fullReset=false){ alarmActive=false; alarmOverlay.style.display='none'; try{ if(alarmSound){ alarmSound.close(); alarmSound=null; } }catch(e){} if(fullReset){ anchorActive=false; if(anchorCircle){ try{ map.removeLayer(anchorCircle); }catch(e){} anchorCircle=null; } document.getElementById('anchorWatch').style.background='rgba(0,0,0,0.4)'; } }
document.addEventListener('mousedown',()=> stopAlarm(true));
document.addEventListener('touchstart',()=> stopAlarm(true));
document.addEventListener('keydown',()=> stopAlarm(true));

/* ------------------------------
   OGPS Marker & Track Export (unver√§ndert)
   ------------------------------ */
function addOGPSMarker(pos){
  const date = new Date();
  const hh = String(date.getHours()).padStart(2,'0');
  const mm = String(date.getMinutes()).padStart(2,'0');
  const label = `OGPS\n${hh}:${mm}\n${date.getFullYear()}.${String(date.getMonth()+1).padStart(2,'0')}.${String(date.getDate()).padStart(2,'0')}`;
  const marker = L.circleMarker(pos, { radius:5, color:'black', fillColor:'black', fillOpacity:1 })
    .addTo(map)
    .bindTooltip(label, { permanent:true, direction:'top', offset:[0,-10] });
  ogpsMarkers.push({ marker: marker, lat: pos[0], lon: pos[1], time: `${hh}:${mm}`, date: `${date.getFullYear()}.${String(date.getMonth()+1).padStart(2,'0')}.${String(date.getDate()).padStart(2,'0')}` });
  if(ogpsMarkers.length > 200){ const r = ogpsMarkers.shift(); try{ map.removeLayer(r.marker); }catch(e){} }
}

/* ------------------------------
   Klickverhalten: Peilmodus vs Routenmodus
   ------------------------------ */
let waypointMarker = null;
let anchorCircle = null;

// Icon-Funktion f√ºr offline Marker (Raute)
function createDiamondIcon(color = 'red', size = 16) {
  return L.divIcon({
    className: 'diamond-marker',
    html: `<div style="
      width:${size}px;
      height:${size}px;
      background:${color};
      transform: rotate(45deg);
      border:2px solid white;"></div>`,
    iconSize: [size, size],
    iconAnchor: [size/2, size/2]
  });
}

map.on('click', e => {
  if (anchorActive) return;

  if (!routeMode) {
    // Peilmodus: einzelner Zielmarker
    if (waypointMarker) { 
      try { map.removeLayer(waypointMarker); } catch(e){} 
      waypointMarker = null; 
    }
    waypointMarker = L.marker(e.latlng, {icon: createDiamondIcon('red')})
                        .addTo(map)
                        .bindPopup("Peilziel")
                        .openPopup();
    return;
  }

  // Routenmodus: neuen Wegpunkt anlegen
  const latlng = e.latlng;
  routePoints.push(latlng);

  const m = L.marker(latlng, { draggable: true, icon: createDiamondIcon('blue') }).addTo(map);
  routeMarkers.push(m);

  // Tooltip / Label
  updateMarkerTooltip(m, routeMarkers.length - 1);

  // Linie neu zeichnen
  updateRouteDisplay();

  // Drag: live updaten
  let tempLine = null;
  m.on('drag', () => {
    const i = routeMarkers.indexOf(m);
    if (i === -1) return;
    routePoints[i] = m.getLatLng();
    updateRouteDisplay();
    updateMarkerTooltip(m, i);

    if (tempLine) { try{ map.removeLayer(tempLine); } catch(e){} tempLine = null; }
    const prev = i === 0 ? { lat: state.gps_lat, lng: state.gps_lon } : routePoints[i - 1];
    tempLine = L.polyline([[prev.lat, prev.lng], [m.getLatLng().lat, m.getLatLng().lng]], {
      color: 'red',
      weight: 4,
      opacity: 0.8,
      dashArray: '6,6'
    }).addTo(map);
  });

  m.on('dragend', () => {
    if (tempLine) { try{ map.removeLayer(tempLine); } catch(e){} tempLine = null; }
    const i = routeMarkers.indexOf(m);
    if (i !== -1) {
      routePoints[i] = m.getLatLng();
      updateRouteDisplay();
      routeMarkers.forEach((mm, idx) => updateMarkerTooltip(mm, idx));
    }
  });

  // Rechtsklick l√∂scht Wegpunkt
  m.on('contextmenu', function(evt) {
    evt.originalEvent.preventDefault();
    const i = routeMarkers.indexOf(m);
    if (i !== -1) removeWaypoint(i);
  });
});

/* ------------------------------
   Marker-Tooltip (WP#, Kurs/Distanz)
   ------------------------------ */
function updateMarkerTooltip(marker, idx) {
  const p = routePoints[idx];
  const prev = idx === 0 ? { lat: state.gps_lat, lng: state.gps_lon } : routePoints[idx - 1];
  const { bearing, distance } = bearingAndDistance(prev.lat, prev.lng, p.lat, p.lng);
  marker.bindTooltip(`WP${idx+1}\n${bearing.toFixed(1)}¬∞ / ${(distance/1852).toFixed(2)} sm`, { permanent: true, offset: [0, -15] });
}

/* ------------------------------
   Route aktualisieren
   ------------------------------ */
function updateRouteDisplay() {
  // Linie entfernen, falls vorhanden
  if (routeLine) { 
    try { map.removeLayer(routeLine); } catch(e){} 
    routeLine = null; 
  }

  // Route zeichnen (Boot als Startpunkt)
  if (routePoints.length > 0) {
    const latlngs = [[state.gps_lat, state.gps_lon], ...routePoints.map(p => [p.lat, p.lng])];
    routeLine = L.polyline(latlngs, { color: '#00aaff', weight: 2, opacity: 0.9 }).addTo(map);
  }

  // Tooltips / Nummerierung aktualisieren
  routeMarkers.forEach((m, i) => updateMarkerTooltip(m, i));

  // Distanz berechnen (Startpunkt = Boot)
  if (routeMode && routePoints.length > 0) {
    let totalDistance = 0;
    let prev = { lat: state.gps_lat, lng: state.gps_lon };
    routePoints.forEach(p => {
      const { distance } = bearingAndDistance(prev.lat, prev.lng, p.lat, p.lng);
      totalDistance += distance;
      prev = p;
    });
    waypointInfo.innerHTML = `<b>Gesamtdistanz Route:</b> ${(totalDistance/1852).toFixed(2)} sm ‚Ä¢ ${routePoints.length} WP`;
  } else {
    waypointInfo.innerHTML = '';
  }
  updateWaypointList();
}

/* ------------------------------
   Wegpunkt entfernen (zentral)
   ------------------------------ */
function removeWaypoint(idx) {
  if (idx < 0 || idx >= routePoints.length) return;

  // remove marker from map & arrays
  try{ map.removeLayer(routeMarkers[idx]); }catch(e){}
  routeMarkers.splice(idx, 1);
  routePoints.splice(idx, 1);

  // rebuild tooltips & route
  updateRouteDisplay();
  updateWaypointList();
}

/* ------------------------------
   Simulation / Integrate (unver√§ndert)
   ------------------------------ */
let t0 = performance.now()/1000;
let lastTime = performance.now();

function integrate(now){
  const nowS = now/1000;
  const dt = (now - lastTime)/1000; lastTime = now;
  const sm = 1 - Math.exp(-2*dt);
  for(const k in state){ if(typeof target[k] === 'number') state[k] = state[k] + (target[k]-state[k]) * sm; }
  updateBoat();
  requestAnimationFrame(integrate);
}
requestAnimationFrame(integrate);

/* ------------------------------
   Live data fetch (unver√§ndert)
   ------------------------------ */
async function fetchLiveData(){
  try {
    const res = await fetch(DATA_URL, { cache:'no-store' });
    if(!res.ok) throw new Error('no data');
    const j = await res.json();
    if('gps_lat' in j) target.gps_lat = Number(j.gps_lat);
    if('gps_lon' in j) target.gps_lon = Number(j.gps_lon);
    if('gps_speed' in j) target.gps_speed = Number(j.gps_speed);
    if('gps_kurs' in j) target.gps_kurs = Number(j.gps_kurs);
    if('kompass' in j) target.kompass = Number(j.kompass);
    if('winddir_berechnet' in j) target.winddir_berechnet = Number(j.winddir_berechnet);
    if('windspeed_berechnet' in j) target.windspeed_berechnet = Number(j.windspeed_berechnet);
    if('winddir_gemessen' in j && !('winddir_berechnet' in j)) target.winddir_berechnet = Number(j.winddir_gemessen);
  } catch(e){
    // remain in demo
  }
}
//setInterval(()=>{ if(!demoMode) fetchLiveData(); }, POLL_INTERVAL_MS);

// WebSocket zur kontinuierlichen Daten√ºbertragung vom ESP
let ws = new WebSocket(`ws://${location.hostname}/ws`);

ws.onopen = () => {
  console.log("WebSocket verbunden");
};

ws.onmessage = (event) => {
  try {
    const j = JSON.parse(event.data);
    if('gps_lat' in j) target.gps_lat = Number(j.gps_lat);
    if('gps_lon' in j) target.gps_lon = Number(j.gps_lon);
    if('gps_speed' in j) target.gps_speed = Number(j.gps_speed);
    if('gps_kurs' in j) target.gps_kurs = Number(j.gps_kurs);
    if('kompass' in j) target.kompass = Number(j.kompass);
    if('winddir_berechnet' in j) target.winddir_berechnet = Number(j.winddir_berechnet);
    if('windspeed_berechnet' in j) target.windspeed_berechnet = Number(j.windspeed_berechnet);
  } catch(e) {
    console.warn("Fehler beim Parsen der WebSocket-Daten:", e);
  }
};

ws.onerror = (err) => { console.error("WebSocket-Fehler:", err); };
ws.onclose = () => {
    console.warn("WebSocket getrennt, reconnect in 3s");
    setTimeout(() => {
        ws = new WebSocket(`ws://${location.hostname}/ws`);
        attachWSHandlers(ws); // Funktion, die onmessage, onopen etc. setzt
    }, 3000);
};

/* ------------------------------
   Buttons / UI wiring (unver√§ndert)
   ------------------------------ */
const centerToggle = document.getElementById('centerToggle');
const saveTrackBtn = document.getElementById('saveTrack');
const anchorWatchBtn = document.getElementById('anchorWatch');
const modeRouteBtn = document.getElementById('modeRoute');

centerToggle.onclick = ()=>{ followMode = !followMode; centerToggle.style.background = followMode ? 'rgba(0,100,0,0.6)' : 'rgba(0,0,0,0.4)'; };
map.on('movestart', ()=>{ if(followMode){ followMode = false; centerToggle.style.background='rgba(0,0,0,0.4)'; } });

saveTrackBtn.onclick = ()=>{ if(ogpsMarkers.length === 0){ alert("Keine OGPS-Marker vorhanden."); return; } let text = "Zeit;Datum;Breitengrad;L√§ngengrad\n"; ogpsMarkers.forEach(p => { text += `${p.time};${p.date};${p.lat.toFixed(6)};${p.lon.toFixed(6)}\n`; }); const blob = new Blob([text], { type:'text/plain' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'track.txt'; a.click(); };

anchorWatchBtn.onclick = ()=>{ if(!anchorActive){ const chainLength = parseFloat(prompt("Ankerkette in Metern:", 30)); if(isNaN(chainLength) || chainLength <= 0) return; const [aLat,aLon] = destinationPoint(state.gps_lat, state.gps_lon, state.kompass, chainLength); anchorPos = { lat: aLat, lon: aLon }; anchorRadius = chainLength + GPS_UNGENAUIGKEIT; if(anchorCircle){ try{ map.removeLayer(anchorCircle); }catch(e){} anchorCircle=null; } anchorCircle = L.circle([aLat,aLon], { radius: anchorRadius, color:'red', fill:false }).addTo(map); anchorActive = true; anchorWatchBtn.style.background = 'rgba(100,0,0,0.6)'; alert("Anker gesetzt! √úberwachung aktiv."); } else { anchorActive = false; if(anchorCircle){ try{ map.removeLayer(anchorCircle); }catch(e){} anchorCircle=null; } stopAlarm(); anchorWatchBtn.style.background = 'rgba(0,0,0,0.4)'; } };

modeRouteBtn.onclick = ()=>{ routeMode = !routeMode; modeRouteBtn.style.background = routeMode ? 'rgba(0,100,100,0.6)' : 'rgba(0,0,0,0.4)'; if(!routeMode){ routeMarkers.forEach(m => { try{ map.removeLayer(m); }catch(e){} }); routeMarkers = []; routePoints = []; if(routeLine) try{ map.removeLayer(routeLine); }catch(e){} routeLine = null; waypointInfo.innerHTML = ""; } else { if(waypointMarker){ try{ map.removeLayer(waypointMarker); }catch(e){} waypointMarker = null; } } };

/* ------------------------------
   Tag/Nachtmodus
   ------------------------------ */
let isNightMode = false;
document.getElementById('nightToggle').addEventListener('click', () => {
  isNightMode = !isNightMode;
  if (isNightMode) { document.body.classList.add('night-mode'); document.getElementById('nightToggle').textContent = 'Tagmodus'; }
  else { document.body.classList.remove('night-mode'); document.getElementById('nightToggle').textContent = 'Nachtmodus'; }
});

/* ------------------------------
   UpdateBoat (mit vollst√§ndigen Reichweitenkreisen wieder eingef√ºgt)
   ------------------------------ */
function updateBoat() {
  const pos = [state.gps_lat, state.gps_lon];
  const pixelSize = 14;
  const angle = state.kompass * Math.PI / 180;

  function offsetPoint(lat, lon, dx, dy) {
    const p = map.latLngToLayerPoint([lat, lon]);
    const p2 = L.point(p.x + dx, p.y + dy);
    return map.layerPointToLatLng(p2);
  }

  const tip = offsetPoint(pos[0], pos[1], Math.sin(angle) * pixelSize, -Math.cos(angle) * pixelSize);
  const leftAngle = angle + Math.PI * 0.75;
  const rightAngle = angle - Math.PI * 0.75;
  const left = offsetPoint(pos[0], pos[1], Math.sin(leftAngle) * pixelSize * 0.6, -Math.cos(leftAngle) * pixelSize * 0.6);
  const right = offsetPoint(pos[0], pos[1], Math.sin(rightAngle) * pixelSize * 0.6, -Math.cos(rightAngle) * pixelSize * 0.6);

  boatTriangle.setLatLngs([tip, right, left]);
  try { boatTriangle.bringToFront(); } catch (e) {}

  const compassEnd = destinationPoint(state.gps_lat, state.gps_lon, state.kompass, 40000);
  const gpsEnd     = destinationPoint(state.gps_lat, state.gps_lon, state.gps_kurs, 40000);
  const windEnd    = destinationPoint(state.gps_lat, state.gps_lon, state.winddir_berechnet, 20000);

  headingLineCompass.setLatLngs([pos, compassEnd]);
  headingLineGPS.setLatLngs([pos, gpsEnd]);
  headingLineWind.setLatLngs([pos, windEnd]);

  ogpsCounter++;
  if (ogpsCounter % 20 === 0) {
    trackPoints.push(pos);
    if (trackPoints.length > 200) trackPoints.shift();
    courseLine.setLatLngs(trackPoints);
  }
  if (ogpsCounter % 300 === 0) addOGPSMarker(pos);

  if (followMode) map.setView(pos, map.getZoom(), { animate: true });

  if (anchorActive && anchorPos) {
    const { distance } = bearingAndDistance(state.gps_lat, state.gps_lon, anchorPos.lat, anchorPos.lon);
    if (distance > anchorRadius) startAlarm();
  }

  legendEl.innerHTML = `üî¥ Kompasskurs: ${state.kompass.toFixed(1)}¬∞<br>üü° GPS-Kurs: ${state.gps_kurs.toFixed(1)}¬∞<br>üü¢ Wind: ${state.winddir_berechnet.toFixed(1)}¬∞ / ${state.windspeed_berechnet.toFixed(1)} kn`;

  if (!routeMode && waypointMarker) {
    const { bearing, distance } = bearingAndDistance(state.gps_lat, state.gps_lon, waypointMarker.getLatLng().lat, waypointMarker.getLatLng().lng);
    waypointInfo.innerHTML = `<b>Peilung zu Ziel:</b><br>Kurs: ${bearing.toFixed(1)}¬∞<br>Entfernung: ${(distance / 1852).toFixed(2)} sm`;
  }

  // ================================
  // --- Reichweitenkreise & Tickmarken ---
  // ================================
  const SM_IN_METERS = 1852;
  const radiusCircles = [
    { r: 2 * SM_IN_METERS, color: '#FF6F61' },
    { r: 5 * SM_IN_METERS, color: '#FF6B61' },
    { r: 10 * SM_IN_METERS, color: '#FF6461' }
  ];

  if (!window.rangeCircles) {
    window.rangeCircles = [];
    window.tickLines = [];
    window.tickLabels = [];
    window.radiusLabels = [];

    radiusCircles.forEach(cfg => {
      // Kreis
      const circle = L.circle([state.gps_lat, state.gps_lon], {
        radius: cfg.r,
        color: cfg.color,
        weight: 1,
        dashArray: "5,5",
        fill: false
      }).addTo(map);
      window.rangeCircles.push(circle);

      // Tickmarken + Beschriftungen (alle 45¬∞)
      for (let brg = 0; brg < 360; brg += 45) {
        const [lat2, lon2] = destinationPoint(state.gps_lat, state.gps_lon, brg, cfg.r);
        const [lat1, lon1] = destinationPoint(state.gps_lat, state.gps_lon, brg, cfg.r * 0.98);
        const tick = L.polyline([[lat1, lon1], [lat2, lon2]], {
          color: cfg.color,
          weight: 1,
          opacity: 0.8
        }).addTo(map);
        window.tickLines.push(tick);

        // Tick-Beschriftung
        const [latLabel, lonLabel] = destinationPoint(state.gps_lat, state.gps_lon, brg, cfg.r * 1.02);
        const label = L.marker([latLabel, lonLabel], {
          icon: L.divIcon({
            className: "tickLabel",
            html: `<div style="color:${cfg.color};font-size:10px;font-weight:bold;">${brg}¬∞</div>`,
            iconSize: [20, 20],
            iconAnchor: [10, 10]
          })
        }).addTo(map);
        window.tickLabels.push(label);
      }

      // Tangential-Striche (rechtwinklig zur Tangente) bei 0¬∞, 90¬∞, 180¬∞, 270¬∞
      [0, 90, 180, 270].forEach(brg => {
        const [latBase, lonBase] = destinationPoint(state.gps_lat, state.gps_lon, brg, cfg.r);
        const perpAngle1 = (brg + 180) % 360;
        const perpAngle2 = brg;
        const [latA, lonA] = destinationPoint(latBase, lonBase, perpAngle1, cfg.r * 0.005);
        const [latB, lonB] = destinationPoint(latBase, lonBase, perpAngle2, cfg.r * 0.005);
        const tangential = L.polyline([[latA, lonA], [latB, lonB]], {
          color: cfg.color,
          weight: 1.5,
          opacity: 0.9
        }).addTo(map);
        window.tickLines.push(tangential);
      });

      // --- Radiusbeschriftung (2 sm / 5 sm / 10 sm) mit eigenem Winkel ---
      const text =
        cfg.r === 2 * SM_IN_METERS ? "2 sm" :
        cfg.r === 5 * SM_IN_METERS ? "5 sm" :
        cfg.r === 10 * SM_IN_METERS ? "10 sm" : "";

      let labelAngle;
      if (cfg.r === 2 * SM_IN_METERS) labelAngle = 0;    // rechts
      else if (cfg.r === 5 * SM_IN_METERS) labelAngle = 90;  // oben
      else if (cfg.r === 10 * SM_IN_METERS) labelAngle = 180; // links

      const [latRadius, lonRadius] = destinationPoint(state.gps_lat, state.gps_lon, labelAngle, cfg.r);
      const radiusLabel = L.marker([latRadius, lonRadius], {
        icon: L.divIcon({
          className: "radiusLabel",
          html: `<div style="color:${cfg.color};font-size:11px;font-weight:small;text-shadow:0px 0px 0px black;">${text}</div>`,
          iconSize: [30, 12],
          iconAnchor: [15, 6]
        })
      }).addTo(map);
      window.radiusLabels.push(radiusLabel);
    });
  } else {
    // Update bestehender Elemente
    let tickIndex = 0;
    let labelIndex = 0;
    let radiusLabelIndex = 0;

    radiusCircles.forEach(cfg => {
      const circle = window.rangeCircles[radiusCircles.indexOf(cfg)];
      if (circle) circle.setLatLng([state.gps_lat, state.gps_lon]);

      // Tickmarken + Tickbeschriftungen aktualisieren
      for (let brg = 0; brg < 360; brg += 45) {
        const [lat2, lon2] = destinationPoint(state.gps_lat, state.gps_lon, brg, cfg.r);
        const [lat1, lon1] = destinationPoint(state.gps_lat, state.gps_lon, brg, cfg.r * 0.98);
        // Correctly set tick polyline if exists:
        if (window.tickLines[tickIndex]) window.tickLines[tickIndex].setLatLngs([[lat1, lon1], [lat2, lon2]]);
        tickIndex++;

        const [latLabel, lonLabel] = destinationPoint(state.gps_lat, state.gps_lon, brg, cfg.r + 1300);
        if (window.tickLabels[labelIndex]) window.tickLabels[labelIndex].setLatLng([latLabel, lonLabel]);
        labelIndex++;
      }

      // Tangential-Striche aktualisieren (4 per circle)
      [0, 90, 180, 270].forEach(brg => {
        const [latBase, lonBase] = destinationPoint(state.gps_lat, state.gps_lon, brg, cfg.r);
        const perpAngle1 = (brg + 180) % 360;
        const perpAngle2 = brg;
        const [latA, lonA] = destinationPoint(latBase, lonBase, perpAngle1, cfg.r * 0.005);
        const [latB, lonB] = destinationPoint(latBase, lonBase, perpAngle2, cfg.r * 0.005);
        if (window.tickLines[tickIndex]) window.tickLines[tickIndex].setLatLngs([[latA, lonA], [latB, lonB]]);
        tickIndex++;
      });

      // Radiusbeschriftung aktualisieren
      let labelAngle;
      if (cfg.r === 2 * SM_IN_METERS) labelAngle = 145;
      else if (cfg.r === 5 * SM_IN_METERS) labelAngle = 145;
      else if (cfg.r === 10 * SM_IN_METERS) labelAngle = 145;

      const [latRadius, lonRadius] = destinationPoint(state.gps_lat, state.gps_lon, labelAngle, cfg.r + 1200);
      if (window.radiusLabels[radiusLabelIndex]) window.radiusLabels[radiusLabelIndex].setLatLng([latRadius, lonRadius]);
      radiusLabelIndex++;
    });
  }
}

function updateWaypointList() {
  const tbody = document.querySelector("#waypointTable tbody");
  if (!tbody) return;
  tbody.innerHTML = "";

  routePoints.forEach((p, i) => {
    const tr = document.createElement("tr");

    const prev = i === 0 ? { lat: state.gps_lat, lng: state.gps_lon } : routePoints[i - 1];
    const fromShip = bearingAndDistance(state.gps_lat, state.gps_lon, p.lat, p.lng);
    const fromPrev = bearingAndDistance(prev.lat, prev.lng, p.lat, p.lng);

    const cells = [
      i + 1,
      p.lat.toFixed(5),
      p.lng.toFixed(5),
      fromShip.bearing.toFixed(1) + "¬∞",
      (fromShip.distance / 1852).toFixed(2),
      i === 0 ? "‚Äî" : fromPrev.bearing.toFixed(1) + "¬∞",
      i === 0 ? "‚Äî" : (fromPrev.distance / 1852).toFixed(2)
    ];

    cells.forEach(val => {
      const td = document.createElement("td");
      td.textContent = val;
      tr.appendChild(td);
    });

    const tdBtn = document.createElement("td");
    const btn = document.createElement("button");
    btn.textContent = "Autopilot";
    btn.onclick = () => sendAutopilotWP(p.lat, p.lng);
    tdBtn.appendChild(btn);
    tr.appendChild(tdBtn);

    tbody.appendChild(tr);
  });
}

// --- Wegpunktliste ein-/ausblenden am unteren Kartenrand ---
let listVisible = false;
const list = document.getElementById('waypointListContainer');

document.addEventListener('mousemove', e => {
  const triggerHeight = window.innerHeight - 30; // 30px vom unteren Rand
  if (e.clientY >= triggerHeight && !listVisible) {
    list.classList.add('visible');
    listVisible = true;
  } else if (e.clientY < triggerHeight - 200 && listVisible) {
    list.classList.remove('visible');
    listVisible = false;
  }
});

function sendAutopilotWP(lat, lon) {
  updateRouteDisplay();
  if(demoMode) {
    console.log(`[Demo] Autopilot WP ‚Üí Lat: ${lat}, Lon: ${lon}`);
    return;
  }
  // ESP erwartet z.B. GET: /autopilot?lat=...&lon=...
  const url = `/autopilot?lat=${lat.toFixed(6)}&lon=${lon.toFixed(6)}`;
  fetch(url)
    .then(res => {
      if(!res.ok) throw new Error("ESP Antwort fehlerhaft");
      return res.text();
    })
    .then(txt => console.log(`ESP-Antwort: ${txt}`))
    .catch(err => console.error("Fehler beim Senden an ESP:", err));
}

/* ------------------------------
   End
   ------------------------------ */
</script>
</body>
</html>
