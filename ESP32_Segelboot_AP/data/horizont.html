<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Horizont — NAVIS Marine Dashboard</title>
<style>
:root{
  --bg:#1c1f26; --panel:#2a2f38; --text:#f4f4f4;
}
body{
  margin:0;
  font-family:"Segoe UI",Roboto,Arial,sans-serif;
  background:var(--bg); color:var(--text);
  display:flex; flex-direction:column; align-items:center;
  height:100vh;
}

/* Navigationsleiste */
#navbar {
  display:flex;
  justify-content:center;
  gap:8px;
  background-color:#002b3a;
  padding:4px 0;
  border-bottom:1px solid #005566;
  width:100%;
  box-shadow:0 0 8px rgba(0,255,255,0.1);
}
.navbtn {
  background-color:#003d52;
  color:#00ffff;
  border:1px solid #007a99;
  border-radius:5px;
  padding:3px 10px;
  text-decoration:none;
  font-size:0.9em;
  font-weight:bold;
  transition:0.2s;
}
.navbtn:hover {
  background-color:#00b8d4;
  color:#001a26;
  border-color:#00e6e6;
}

.panel{
  background:var(--panel);
  border-radius:12px;
  padding:8px;
  box-shadow:0 8px 28px rgba(0,0,0,0.6);
  margin-top:8px;
}
#horizonCanvas{width:90vmin;height:90vmin;display:block;border-radius:50%;}
</style>
</head>
<body>

<!-- Navigationsleiste -->
<div id="navbar">
  <a href="index.html" class="navbtn">NAVIS</a>
  <a href="kompass.html" class="navbtn">Kompass</a>
  <a href="karte.html" class="navbtn">Karte</a>
  <a href="autopilot.html" class="navbtn">Autopilot</a>
</div>

<div class="panel">
  <canvas id="horizonCanvas" width="400" height="400"></canvas>
</div>

<script>
const DATA_URL = '/data.json';

const state = { roll: 0, pitch: 0 };
const target = { roll: 0, pitch: 0 };

let socket = new WebSocket("ws://" + window.location.host + "/ws");

socket.onopen = () => {
  console.log("WebSocket verbunden");
};

socket.onmessage = (event) => {
  try {
    const data = JSON.parse(event.data);
    if ("roll" in data) target.roll = Number(data.roll);
    if ("pitch" in data) target.pitch = Number(data.pitch);
  } catch (e) {
    console.warn("Ungültige WS-Daten:", e);
  }
};

socket.onclose = () => {
  console.warn("WebSocket getrennt – reconnect…");
  setTimeout(() => {
    socket = new WebSocket("ws://" + window.location.host + "/ws");
  }, 1000);
};


const hCanvas = document.getElementById('horizonCanvas');
const hctx = hCanvas.getContext('2d');

function drawHorizon(){
  const w = hCanvas.width, h = hCanvas.height;
  const cx = w/2, cy = h/2;
  const r = Math.min(cx, cy) - 10;
  hctx.clearRect(0,0,w,h);
  hctx.save();
  hctx.beginPath();
  hctx.arc(cx, cy, r, 0, Math.PI * 2);
  hctx.clip();

  hctx.save();
  hctx.translate(cx, cy);
  hctx.rotate(-state.roll * Math.PI/180);

  const maxPitch = 45;
  const pitchPixels = (state.pitch / maxPitch) * (r * 0.6);

  // Himmel
  const skyTop = -r*2 + pitchPixels;
  const skyGrad = hctx.createLinearGradient(0, skyTop, 0, r*2 + pitchPixels);
  skyGrad.addColorStop(0, '#204b9b');
  skyGrad.addColorStop(0.6, '#3c7fd0');
  hctx.fillStyle = skyGrad;
  hctx.fillRect(-r*2, skyTop, r*4, r*2);

  // Meer
  const seaTop = 0 + pitchPixels;
  const seaGrad = hctx.createLinearGradient(0, seaTop, 0, r*2 + pitchPixels);
  seaGrad.addColorStop(0, '#15301a');
  seaGrad.addColorStop(1, '#07140a');
  hctx.fillStyle = seaGrad;
  hctx.fillRect(-r*2, seaTop, r*4, r*4);

  // Horizontlinie
  hctx.strokeStyle = 'rgba(255,255,255,0.95)';
  hctx.lineWidth = 3;
  hctx.beginPath();
  hctx.moveTo(-r*1.15, pitchPixels);
  hctx.lineTo(r*1.15, pitchPixels);
  hctx.stroke();

  // Pitch-Ticks
  hctx.lineWidth = 1.2;
  hctx.strokeStyle = 'rgba(255,255,255,0.75)';
  hctx.fillStyle = '#fff';
  hctx.font = '12px Segoe UI';
  const pitchStep = 5;
  const tickScale = (r / maxPitch) * 0.6;
  for(let p = -60; p <= 60; p += pitchStep){
    const y = -p * tickScale + pitchPixels;
    if(Math.abs(y) > r) continue;
    const len = (p % 15 === 0) ? 44 : 22;
    hctx.beginPath();
    hctx.moveTo(-len, y);
    hctx.lineTo(len, y);
    hctx.stroke();
    if(p % 15 === 0 && p !== 0){
      hctx.textAlign = 'center';
      hctx.fillText((-p) + '°', -len - 14, y - 6);
      hctx.fillText((-p) + '°', len + 14, y - 6);
    }
  }

  hctx.restore();

  // Roll-Ticks
  hctx.save();
  hctx.translate(cx, cy);
  for(let a = -90; a <= 90; a += 5){
    const ang = a * Math.PI / 180;
    const inner = (a % 15 === 0) ? r - 14 : r - 8;
    const outer = r - 4;
    const x1 = inner * Math.sin(ang);
    const y1 = -inner * Math.cos(ang);
    const x2 = outer * Math.sin(ang);
    const y2 = -outer * Math.cos(ang);
    hctx.beginPath();
    hctx.moveTo(x1, y1);
    hctx.lineTo(x2, y2);
    hctx.strokeStyle = 'rgba(255,255,255,0.35)';
    hctx.lineWidth = 1;
    hctx.stroke();

    if(a % 15 === 0){
      const labelR = r - 30;
      const lx = labelR * Math.sin(ang);
      const ly = -labelR * Math.cos(ang);
      hctx.save();
      hctx.translate(lx, ly);
      hctx.rotate(ang * 0.9);
      hctx.fillStyle = '#e6e9eb';
      hctx.font = '12px Segoe UI';
      hctx.textAlign = 'center';
      hctx.textBaseline = 'middle';
      hctx.fillText(a + '°', 0, 0);
      hctx.restore();
    }
  }

  // Dreieck Mittelpunkt
  hctx.save();
  hctx.rotate(-state.roll * Math.PI/180);
  const triTipRadius = r - 4;
  const triBaseRadius = r - 22;
  const triHalfWidth = 10;
  hctx.beginPath();
  hctx.moveTo(0, -triTipRadius);
  hctx.lineTo(-triHalfWidth, -triBaseRadius);
  hctx.lineTo(triHalfWidth, -triBaseRadius);
  hctx.closePath();
  hctx.fillStyle = '#ffcc33';
  hctx.fill();
  hctx.strokeStyle = 'rgba(0,0,0,0.45)';
  hctx.lineWidth = 1;
  hctx.stroke();
  hctx.restore();

  hctx.restore();

  // Zentrumskreuz
  hctx.save();
  hctx.strokeStyle = '#ffcc33';
  hctx.lineWidth = 2;
  hctx.beginPath();
  hctx.moveTo(cx - 12, cy);
  hctx.lineTo(cx + 12, cy);
  hctx.moveTo(cx, cy);
  hctx.lineTo(cx, cy - 12);
  hctx.stroke();
  hctx.restore();
}

// Animation: sanft auf neue Werte
let lastTime = performance.now();
function integrate(now){
  const dt = (now - lastTime)/1000;
  lastTime = now;
  const lerp = (a,b,t)=>a+(b-a)*t;
  const sm = 1 - Math.exp(-2*dt);
  for(const k in state){ if(typeof target[k]==='number') state[k]=lerp(state[k],target[k],sm); }

  drawHorizon();
  requestAnimationFrame(integrate);
}

requestAnimationFrame(integrate);
</script>
</body>
</html>
